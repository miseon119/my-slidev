"use strict";Object.defineProperty(exports, "__esModule", {value: true});var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

// src/core/utils.ts
var _installpkg = require('@antfu/install-pkg');
var _utils = require('@antfu/utils');
var _kolorist = require('kolorist');
function camelize(str) {
  return str.replace(/-([a-z0-9])/g, (g) => g[1].toUpperCase());
}
function pascalize(str) {
  const camel = camelize(str);
  return camel[0].toUpperCase() + camel.slice(1);
}
function camelToKebab(key) {
  const result = key.replace(/:/g, "-").replace(/([A-Z])/g, " $1").trim();
  return result.split(/\s+/g).join("-").toLowerCase();
}
function snakelize(str) {
  const kebab = camelToKebab(str);
  return kebab.replace(/-/g, "_");
}
var warnned = /* @__PURE__ */ new Set();
function warnOnce(msg) {
  if (!warnned.has(msg)) {
    warnned.add(msg);
    console.warn(_kolorist.yellow.call(void 0, `[unplugin-icons] ${msg}`));
  }
}
async function mergeIconProps(svg, collection, icon, query, propsProvider, options) {
  var _a, _b, _c, _d;
  const props = (_c = await (propsProvider == null ? void 0 : propsProvider())) != null ? _c : {
    height: `${(_a = options == null ? void 0 : options.scale) != null ? _a : 1}em`,
    width: `${(_b = options == null ? void 0 : options.scale) != null ? _b : 1}em`
  };
  await ((_d = options == null ? void 0 : options.iconCustomizer) == null ? void 0 : _d.call(options, collection, icon, props));
  Object.keys(query).forEach((p) => {
    const v = query[p];
    if (p !== "raw" && v !== void 0 && v !== null)
      props[p] = v;
  });
  return svg.replace("<svg", `<svg ${Object.keys(props).map((p) => `${p}="${props[p]}"`).join(" ")}`);
}
var pending;
var tasks = {};
async function tryInstallPkg(name) {
  if (pending)
    await pending;
  if (!tasks[name]) {
    console.log(_kolorist.cyan.call(void 0, `Installing ${name}...`));
    tasks[name] = pending = _installpkg.installPackage.call(void 0, name, { dev: true, preferOffline: true }).then(() => _utils.sleep.call(void 0, 300)).catch((e) => {
      warnOnce(`Failed to install ${name}`);
      console.error(e);
    }).finally(() => {
      pending = void 0;
    });
  }
  return tasks[name];
}











exports.__spreadValues = __spreadValues; exports.__spreadProps = __spreadProps; exports.camelize = camelize; exports.pascalize = pascalize; exports.camelToKebab = camelToKebab; exports.snakelize = snakelize; exports.warnOnce = warnOnce; exports.mergeIconProps = mergeIconProps; exports.tryInstallPkg = tryInstallPkg;
