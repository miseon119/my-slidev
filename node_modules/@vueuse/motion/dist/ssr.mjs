import { createObjectProperty, findProp, createSimpleExpression, createObjectExpression, createCallExpression, MERGE_PROPS, isText } from '@vue/compiler-core';
import { isString } from '@vueuse/core';
import { parse } from '@babel/parser';

function evaluateValue(expression) {
  const ret = { status: "ng", value: void 0 };
  try {
    const ast = parse(`const a = ${expression.trim()}`);
    const node = ast.program.body[0].declarations[0].init;
    if (node.type === "ObjectExpression") {
      const val = new Function(`return ${expression.trim()}`)();
      ret.status = "ok";
      ret.value = val;
    }
  } catch (e) {
  }
  return ret;
}
function parseExpression(expression) {
  const ret = {
    path: "",
    named: {},
    options: {}
  };
  try {
    const ast = parse(`const a = ${expression.trim()}`);
    const node = ast.program.body[0].declarations[0].init;
    if (node.type === "StringLiteral") {
      ret.path = node.extra.raw;
    } else if (node.type === "Identifier") {
      ret.path = node.name;
    } else if (node.type === "MemberExpression") {
      ret.path = getObjectMemberValue(node);
    } else if (node.type === "ObjectExpression") {
      node.properties.forEach((propNode) => {
        const propKeyNode = propNode.key;
        if (propKeyNode.type !== "Identifier") {
          return;
        }
        const propValueNode = propNode.value;
        switch (propKeyNode.name) {
          case "path":
            ret.path = getObjectMemberValue(propValueNode);
            break;
          case "locale":
            ret.options.locale = getObjectMemberValue(propValueNode);
            break;
          case "choice":
          case "plural":
            ret.options.plural = getObjectMemberValue(propValueNode);
            break;
          case "args":
            traverseObjectMember(propValueNode, ret.named);
            break;
          default:
            break;
        }
      });
    }
  } catch (e) {
  }
  return ret;
}
function getObjectMemberValue(node) {
  if (node.type === "StringLiteral" || node.type === "NumericLiteral") {
    return node.extra.raw;
  } else if (node.type === "Identifier") {
    return node.name;
  } else if (node.type === "MemberExpression") {
    const paths = [];
    collectMemberPath(node, paths);
    paths.reverse();
    return paths.join(".");
  } else {
    return "";
  }
}
function traverseObjectMember(node, target) {
  node.properties.forEach((propNode) => {
    const propKeyNode = propNode.key;
    if (propKeyNode.type !== "Identifier") {
      return;
    }
    if (!(propKeyNode.name in target)) {
      target[propKeyNode.name] = {};
    }
    const propValueNode = propNode.value;
    if (propValueNode.type === "ObjectExpression") {
      traverseObjectMember(propValueNode, target[propKeyNode.name]);
    } else {
      target[propKeyNode.name] = getObjectMemberValue(propValueNode);
    }
  });
}
function collectMemberPath(node, paths) {
  if (node.type === "Identifier") {
    paths.push(node.name);
    return;
  }
  if (node.property.type === "Identifier") {
    paths.push(node.property.name);
    return collectMemberPath(node.object, paths);
  }
}

function transform(variants) {
  return (dir, node, context) => {
    const result = { props: [], needRuntime: true };
    const { exp } = dir;
    if (exp) {
      console.log(createObjectProperty("style", exp));
    }
    const prop = findProp(node, "initial", true, false);
    if (!isBindDirective(prop) || prop.exp == null || prop.arg == null) {
      return result;
    }
    result.props = [
      createObjectProperty(`style`, createStyleObjectExpressionFromDirectiveNode(prop, node, context))
    ];
    return result;
  };
}
const isSymbol = (val) => typeof val === "symbol";
const isBindDirective = (prop) => prop != null && prop.type === 7 && prop.name === "bind";
const isSimpleExpressionNode = (node) => node != null && node.type === 4;
const isCompoundExpressionNode = (node) => node != null && node.type === 8;
function mapNodeContentHanlder(value) {
  if (isString(value)) {
    return value;
  } else if (isSymbol(value)) {
    return value.description || "";
  } else if (isSimpleExpressionNode(value)) {
    return value.content;
  } else if (isCompoundExpressionNode(value)) {
    return value.children.map(mapNodeContentHanlder).join("");
  } else if (isText(value)) {
    if (isString(value.content)) {
      return value.content;
    } else if (isSimpleExpressionNode(value.content)) {
      return value.content.content;
    } else if (isCompoundExpressionNode(value.content)) {
      return value.content.children.map(mapNodeContentHanlder).join("");
    } else {
      return "";
    }
  } else {
    return "";
  }
}
function isConstant(node) {
  if ("isConstant" in node) {
    return node.isConstant;
  } else if ("constType" in node) {
    return node.constType > 0;
  } else {
    throw Error("Unexpected error while transforming a v-motion directive.");
  }
}
function createStyleObjectExpressionFromDirectiveNode(prop, node, context) {
  const properties = [];
  prop.exp.content;
  if (isSimpleExpressionNode(prop.exp)) {
    if (isConstant(prop.exp)) {
      const { status, value } = evaluateValue(prop.exp.content);
      if (status === "ok") {
        for (const [key, val] of Object.entries(value)) {
          properties.push(createObjectProperty(key, createSimpleExpression(String(val), true, prop.loc, 3)));
        }
      }
      return createObjectExpression(properties, node.loc);
    } else {
      if (isSimpleExpressionNode(prop.arg) && isConstant(prop.arg)) {
        const source = createSimpleExpression(prop.exp.content, false, prop.loc, 0);
        const from = createObjectExpression([], prop.loc);
        return createCallExpression(context.helper(MERGE_PROPS), [source, from], node.loc);
      } else {
        return createObjectExpression(properties, node.loc);
      }
    }
  } else if (isCompoundExpressionNode(prop.exp)) {
    const expression = prop.exp.children.map(mapNodeContentHanlder).join("");
    const source = createSimpleExpression(expression, false, prop.loc, 0);
    const from = createObjectExpression([], prop.loc);
    return createCallExpression(context.helper(MERGE_PROPS), [source, from], node.loc);
  } else {
    return createObjectExpression(properties, node.loc);
  }
}

export { evaluateValue, parseExpression, transform };
